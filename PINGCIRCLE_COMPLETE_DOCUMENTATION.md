# 🚀 PingCircle Chat Application - Complete Documentation

## 📋 Table of Contents
1. [Project Overview](#project-overview)
2. [System Architecture](#system-architecture)
3. [Technology Stack](#technology-stack)
4. [Database Schema](#database-schema)
5. [Authentication System](#authentication-system)
6. [User Management Features](#user-management-features)
7. [Real-time Chat Features](#real-time-chat-features)
8. [Scheduled Messages](#scheduled-messages)
9. [User Pinning System](#user-pinning-system)
10. [API Documentation](#api-documentation)
11. [Frontend Components](#frontend-components)
12. [Data Flow Diagrams](#data-flow-diagrams)
13. [Security Features](#security-features)
14. [Deployment Guide](#deployment-guide)

---

## 🎯 Project Overview

**PingCircle** is a real-time chat application with advanced features including user authentication, real-time messaging, scheduled messages, user pinning, and more.

### Key Features:
- ✅ Real-time messaging (public and private)
- ✅ User authentication with JWT
- ✅ User search and management
- ✅ Scheduled messages and reminders
- ✅ User pinning system
- ✅ Online user tracking
- ✅ Message history
- ✅ Responsive design

---

## 🏗️ System Architecture

### Architecture Pattern: Client-Server with WebSocket
```
┌─────────────────┐    HTTP/REST    ┌─────────────────┐
│   React Frontend │ ◄──────────────► │  Spring Boot    │
│                 │                 │   Backend       │
└─────────────────┘                 └─────────────────┘
         │                                   │
         │ WebSocket/STOMP                   │
         ▼                                   ▼
┌─────────────────┐                 ┌─────────────────┐
│   WebSocket     │                 │   MySQL         │
│   Connection    │                 │   Database      │
└─────────────────┘                 └─────────────────┘
```

### Data Flow:
1. **Frontend** → **Backend** (HTTP requests for CRUD operations)
2. **Frontend** ↔ **Backend** (WebSocket for real-time messaging)
3. **Backend** → **Database** (JPA/Hibernate for data persistence)

---

## 🛠️ Technology Stack

### Backend:
- **Framework**: Spring Boot 3.2.7
- **Language**: Java 17
- **Database**: MySQL 8.0
- **ORM**: JPA/Hibernate
- **Security**: Spring Security + JWT
- **WebSocket**: STOMP over SockJS
- **Build Tool**: Maven

### Frontend:
- **Framework**: React 18
- **Build Tool**: Vite
- **Routing**: React Router DOM
- **HTTP Client**: Axios
- **WebSocket**: STOMP.js + SockJS
- **UI Framework**: Bootstrap 5
- **State Management**: React Hooks

### Database:
- **RDBMS**: MySQL
- **Connection**: JDBC
- **Schema**: Auto-generated by Hibernate

---

## 🗄️ Database Schema

### 1. Users Table
```sql
CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(20) UNIQUE NOT NULL,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 2. Chat Messages Table
```sql
CREATE TABLE chat_message (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    sender_name VARCHAR(255),
    receiver_name VARCHAR(255),
    message TEXT,
    status VARCHAR(50),
    timestamp BIGINT NOT NULL
);
```

### 3. Scheduled Messages Table
```sql
CREATE TABLE scheduled_messages (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    sender_name VARCHAR(255),
    receiver_name VARCHAR(255),
    message TEXT,
    status VARCHAR(50),
    scheduled_time BIGINT NOT NULL,
    created_at BIGINT NOT NULL,
    is_sent BOOLEAN DEFAULT FALSE,
    message_type VARCHAR(50),
    reminder_title VARCHAR(255),
    reminder_description TEXT
);
```

### 4. Pinned Users Table
```sql
CREATE TABLE user_pinned_chats (
    user_id BIGINT,
    pinned_username VARCHAR(255),
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

---

## 🔐 Authentication System

### JWT Token Flow:

#### 1. User Login Process:
```
User Input → Frontend → Backend → Database → JWT Token → Frontend Storage
```

**Frontend (Login.jsx):**
```javascript
// User enters credentials
const response = await api.post("/users/login", {
    username: username.trim(),
    password: password.trim(),
});

// Store JWT token in cookie
setJwtCookie(response.data.token);
```

**Backend (UserController.java):**
```java
@PostMapping("/login")
public ResponseEntity<?> login(@Valid @RequestBody LoginRequest loginRequest) {
    String token = userService.authenticateUser(loginRequest.getUsername(), loginRequest.getPassword());
    return ResponseEntity.ok(new LoginResponse(token, username, "Login successful"));
}
```

**Service Layer (UserService.java):**
```java
public String authenticateUser(String username, String password) {
    Users user = userRepository.findByUsername(username);
    if (passwordEncoder.matches(password, user.getPassword())) {
        return jwtService.generateToken(username);
    }
    throw new RuntimeException("Invalid credentials");
}
```

#### 2. JWT Token Storage:
- **Method**: Browser Cookies (client-side)
- **Security**: SameSite=Strict, Secure flag in HTTPS
- **Expiration**: 7 days
- **Access**: JavaScript can read/write (not httpOnly)

#### 3. Token Validation:
**Frontend (axios.js):**
```javascript
api.interceptors.request.use((config) => {
    const token = getJwtCookie();
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
});
```

**Backend (JwtAuthenticationFilter.java):**
```java
@Override
protected void doFilterInternal(HttpServletRequest request, ...) {
    final String authHeader = request.getHeader("Authorization");
    if (authHeader != null && authHeader.startsWith("Bearer ")) {
        String jwt = authHeader.substring(7);
        String username = jwtService.extractUsername(jwt);
        // Validate token and set authentication context
    }
}
```

---

## 👥 User Management Features

### 1. User Registration

**User Journey:**
1. User clicks "Sign up" on login page
2. Fills registration form (username, name, email, password)
3. Frontend validates input
4. Backend creates user account
5. User is automatically logged in

**Frontend (SignupForm.jsx):**
```javascript
const handleSubmit = async (e) => {
    const payload = { username, name, email, password };
    const response = await api.post("/users/signup", payload);
    if (response.data && response.data.token) {
        setJwtCookie(response.data.token);
        onSignupSuccess(username);
    }
};
```

**Backend (UserController.java):**
```java
@PostMapping("/signup")
public ResponseEntity<?> signup(@Valid @RequestBody UserDto userDto) {
    Users user = userService.createUser(userDto);
    String token = userService.authenticateUser(userDto.getUsername(), userDto.getPassword());
    return ResponseEntity.ok(new LoginResponse(token, username, "User created successfully"));
}
```

**Service Layer (UserService.java):**
```java
public Users createUser(UserDto userDto) {
    if (userRepository.existsByUsername(userDto.getUsername())) {
        throw new RuntimeException("Username already exists");
    }
    
    Users user = new Users();
    user.setUsername(userDto.getUsername());
    user.setName(userDto.getName());
    user.setEmail(userDto.getEmail());
    user.setPassword(passwordEncoder.encode(userDto.getPassword()));
    
    return userRepository.save(user);
}
```

### 2. User Search

**User Journey:**
1. User types in search bar
2. Frontend sends search request
3. Backend searches database
4. Results displayed in user list

**Frontend (SearchBar.jsx):**
```javascript
const handleSearch = async (searchTerm) => {
    const response = await api.get(`/users/search?searchTerm=${searchTerm}`);
    setSearchResults(response.data);
};
```

**Backend (UserController.java):**
```java
@GetMapping("/search")
public ResponseEntity<List<Users>> searchUsers(@RequestParam String searchTerm) {
    List<Users> users = userService.searchUsers(searchTerm);
    return ResponseEntity.ok(users);
}
```

**Repository (UserRepository.java):**
```java
@Query("SELECT u FROM Users u WHERE u.username LIKE %:searchTerm% OR u.name LIKE %:searchTerm%")
List<Users> findByUsernameContainingOrNameContaining(@Param("searchTerm") String searchTerm);
```

### 3. Account Deletion

**User Journey:**
1. User clicks "Delete Account" in dashboard
2. Confirmation dialog appears
3. User types "DELETE" to confirm
4. Account and all data are permanently deleted
5. User is logged out

**Frontend (UserDashboard.jsx):**
```javascript
const handleDeleteAccount = async () => {
    const userInput = prompt("Type DELETE to confirm...");
    if (userInput === "DELETE") {
        const response = await api.delete(`/users/deleteAccount?username=${username}`);
        localStorage.removeItem("chat-username");
        removeJwtCookie();
        onLogout();
    }
};
```

**Backend (UserController.java):**
```java
@DeleteMapping("/deleteAccount")
public ResponseEntity<?> deleteAccount(@RequestParam String username) {
    userService.deleteAccount(username);
    return ResponseEntity.ok("Account deleted successfully");
}
```

---

## 💬 Real-time Chat Features

### 1. WebSocket Connection

**Connection Setup:**
```javascript
// Frontend (useWebSocket.js)
const socket = new SockJS('http://localhost:8080/ws');
stompClient = over(socket);

stompClient.connect({}, () => {
    // Subscribe to public chat
    stompClient.subscribe('/chatroom/public', (payload) => {
        handlePublicMessage(JSON.parse(payload.body));
    });
    
    // Subscribe to private messages
    stompClient.subscribe(`/user/${username}/private`, (payload) => {
        handlePrivateMessage(JSON.parse(payload.body));
    });
});
```

**Backend Configuration (WebSocketConfig.java):**
```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws")
                .setAllowedOriginPatterns("*")
                .withSockJS();
    }
    
    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.setApplicationDestinationPrefixes("/app");
        registry.enableSimpleBroker("/chatroom", "/user");
        registry.setUserDestinationPrefix("/user");
    }
}
```

### 2. Public Chat Messages

**User Journey:**
1. User selects "Chat Room" tab
2. Types message in input field
3. Clicks send or presses Enter
4. Message appears in real-time for all users

**Frontend (ChatPage.jsx):**
```javascript
const sendMessage = () => {
    if (message.trim()) {
        const chatMessage = {
            senderName: username,
            message: message,
            status: 'MESSAGE'
        };
        stompClient.send('/app/message', {}, JSON.stringify(chatMessage));
        setMessage('');
    }
};
```

**Backend (ChatController.java):**
```java
@MessageMapping("/message")
@SendTo("/chatroom/public")
public Message receiveMessage(Message message) {
    message.setReceiverName("PUBLIC");
    message.setStatus(Status.MESSAGE);
    
    if (Status.MESSAGE.equals(message.getStatus()) && 
        message.getMessage() != null && !message.getMessage().trim().isEmpty()) {
        ChatMessage savedMessage = chatService.saveMessage(message);
    }
    
    return message;
}
```

**Database Storage:**
```java
// ChatService.java
public ChatMessage saveMessage(Message message) {
    ChatMessage chatMessage = new ChatMessage(
        message.getSenderName(),
        message.getReceiverName(),
        message.getMessage(),
        message.getStatus(),
        System.currentTimeMillis()
    );
    return chatMessageRepository.save(chatMessage);
}
```

### 3. Private Messages

**User Journey:**
1. User selects a specific user from the list
2. Types private message
3. Message sent only to selected user
4. Both sender and receiver see the message

**Frontend (ChatPage.jsx):**
```javascript
const sendPrivate = () => {
    if (message.trim() && receiver) {
        const chatMessage = {
            senderName: username,
            receiverName: receiver,
            message: message,
            status: 'MESSAGE'
        };
        stompClient.send('/app/private-message', {}, JSON.stringify(chatMessage));
        setMessage('');
    }
};
```

**Backend (ChatController.java):**
```java
@MessageMapping("/private-message")
public void privateMessage(Message message) {
    message.setStatus(Status.MESSAGE);
    
    ChatMessage savedMessage = chatService.saveMessage(message);
    
    // Send to receiver
    simpMessagingTemplate.convertAndSendToUser(
        message.getReceiverName(), 
        "/private", 
        message
    );
    
    // Send back to sender
    simpMessagingTemplate.convertAndSendToUser(
        message.getSenderName(), 
        "/private", 
        message
    );
}
```

### 4. Message History

**Loading Chat History:**
```javascript
// Frontend (ChatPage.jsx)
const fetchChatHistory = async (sender, receiver) => {
    const response = await api.get(`/chat/messages?senderName=${sender}&receiverName=${receiver}`);
    setPrivateChats(prev => {
        const newChats = new Map(prev);
        newChats.set(receiver, response.data);
        return newChats;
    });
};
```

**Backend (ChatController.java):**
```java
@GetMapping("/messages")
public ResponseEntity<List<ChatMessage>> getMessages(
        @RequestParam String senderName, 
        @RequestParam String receiverName) {
    List<ChatMessage> messages = chatService.getMessages(senderName, receiverName);
    return ResponseEntity.ok(messages);
}
```

---

## ⏰ Scheduled Messages

### 1. Message Scheduling

**User Journey:**
1. User clicks "Schedule" button (📅 icon)
2. Modal opens with scheduling form
3. User selects message type, date, time, and content
4. Message is scheduled for future delivery

**Frontend (ScheduledMessageModal.jsx):**
```javascript
const handleSubmit = async (e) => {
    const calculatedScheduledTime = new Date(`${scheduledDate}T${scheduledTime}`).getTime();
    
    const requestData = {
        senderName: currentUser,
        receiverName: selectedUser,
        message,
        scheduledTime: calculatedScheduledTime,
        messageType,
        reminderTitle,
        reminderDescription
    };
    
    await onSchedule(requestData);
};
```

**Backend (ChatController.java):**
```java
@PostMapping("/schedule-message")
public ResponseEntity<?> scheduleMessage(@RequestBody ScheduledMessageRequest request) {
    ScheduledMessage scheduledMessage = scheduledMessageService.scheduleMessage(request);
    return ResponseEntity.ok(scheduledMessage);
}
```

**Service Layer (ScheduledMessageService.java):**
```java
public ScheduledMessage scheduleMessage(ScheduledMessageRequest request) {
    ScheduledMessage scheduledMessage = new ScheduledMessage(
        request.getSenderName(),
        request.getReceiverName(),
        request.getMessage(),
        Status.MESSAGE,
        request.getScheduledTime(),
        request.getMessageType(),
        request.getReminderTitle(),
        request.getReminderDescription()
    );
    
    return scheduledMessageRepository.save(scheduledMessage);
}
```

### 2. Automatic Message Processing

**Scheduled Task (ScheduledMessageService.java):**
```java
@Scheduled(fixedRate = 30000) // Run every 30 seconds
public void processScheduledMessages() {
    long currentTime = System.currentTimeMillis();
    List<ScheduledMessage> messagesToSend = scheduledMessageRepository.findMessagesToSend(currentTime);
    
    for (ScheduledMessage scheduledMessage : messagesToSend) {
        sendScheduledMessage(scheduledMessage);
    }
}

private void sendScheduledMessage(ScheduledMessage scheduledMessage) {
    // Create regular message
    Message message = new Message();
    message.setSenderName(scheduledMessage.getSenderName());
    message.setReceiverName(scheduledMessage.getReceiverName());
    message.setMessage(scheduledMessage.getMessage());
    message.setStatus(scheduledMessage.getStatus());
    
    // Save to chat history
    ChatMessage savedChatMessage = chatService.saveMessage(message);
    
    // Send via WebSocket
    messagingTemplate.convertAndSendToUser(
        scheduledMessage.getReceiverName(), 
        "/private", 
        message
    );
    
    // Mark as sent
    scheduledMessage.setIsSent(true);
    scheduledMessageRepository.save(scheduledMessage);
}
```

### 3. Message Types

**Supported Types:**
- **SCHEDULED**: One-time scheduled message
- **REMINDER**: Reminder with title and description
- **BIRTHDAY**: Annual birthday reminder
- **ANNIVERSARY**: Annual anniversary reminder

**Database Query (ScheduledMessageRepository.java):**
```java
@Query("SELECT sm FROM ScheduledMessage sm WHERE sm.isSent = false AND sm.scheduledTime <= :currentTime ORDER BY sm.scheduledTime ASC")
List<ScheduledMessage> findMessagesToSend(@Param("currentTime") Long currentTime);
```

---

## 📌 User Pinning System

### 1. Pin/Unpin Users

**User Journey:**
1. User clicks pin icon (📌) next to a user
2. User appears in "Pinned Users" section
3. Click again to unpin

**Frontend (UserChatItem.jsx):**
```javascript
const handlePinToggle = async (e) => {
    e.stopPropagation();
    const response = await api.post('/users/pinUser', {
        username: currentUser,
        pinnedUsername: user.username,
        pin: !isPinned
    });
    onPinToggle(user.username);
};
```

**Backend (UserController.java):**
```java
@PostMapping("/pinUser")
public ResponseEntity<?> pinUser(@Valid @RequestBody PinUserRequest request) {
    if (request.isPin()) {
        userService.pinUser(request.getUsername(), request.getPinnedUsername());
        return ResponseEntity.ok("User pinned successfully");
    } else {
        userService.unpinUser(request.getUsername(), request.getPinnedUsername());
        return ResponseEntity.ok("User unpinned successfully");
    }
}
```

**Service Layer (UserService.java):**
```java
public void pinUser(String username, String pinnedUsername) {
    Users user = userRepository.findByUsername(username);
    user.getPinnedUsers().add(pinnedUsername);
    userRepository.save(user);
}

public void unpinUser(String username, String pinnedUsername) {
    Users user = userRepository.findByUsername(username);
    user.getPinnedUsers().remove(pinnedUsername);
    userRepository.save(user);
}
```

### 2. Pinned Users Display

**Frontend (PinnedUsers.jsx):**
```javascript
const fetchPinnedUsers = async () => {
    const response = await api.get(`/users/pinnedUsers?username=${currentUser}`);
    setPinnedUsers(response.data);
};
```

**Backend (UserController.java):**
```java
@GetMapping("/pinnedUsers")
public ResponseEntity<Set<String>> getPinnedUsers(@RequestParam String username) {
    Set<String> pinnedUsers = userService.getPinnedUsers(username);
    return ResponseEntity.ok(pinnedUsers);
}
```

---

## 📡 API Documentation

### Authentication Endpoints

#### POST /api/users/login
**Purpose**: User login
**Request Body**:
```json
{
    "username": "string",
    "password": "string"
}
```
**Response**:
```json
{
    "token": "jwt_token_string",
    "username": "string",
    "message": "string"
}
```

#### POST /api/users/signup
**Purpose**: User registration
**Request Body**:
```json
{
    "username": "string",
    "name": "string",
    "email": "string",
    "password": "string"
}
```
**Response**:
```json
{
    "token": "jwt_token_string",
    "username": "string",
    "message": "string"
}
```

### User Management Endpoints

#### GET /api/users/search?searchTerm=string
**Purpose**: Search users
**Response**: `List<Users>`

#### GET /api/users/onlineUsers
**Purpose**: Get online users
**Response**: `Set<String>`

#### GET /api/users/pinnedUsers?username=string
**Purpose**: Get user's pinned users
**Response**: `Set<String>`

#### POST /api/users/pinUser
**Purpose**: Pin/unpin a user
**Request Body**:
```json
{
    "username": "string",
    "pinnedUsername": "string",
    "pin": boolean
}
```

#### DELETE /api/users/deleteAccount?username=string
**Purpose**: Delete user account

### Chat Endpoints

#### GET /api/chat/messages?senderName=string&receiverName=string
**Purpose**: Get chat history
**Response**: `List<ChatMessage>`

#### GET /api/chat/scheduled-messages?senderName=string
**Purpose**: Get user's scheduled messages
**Response**: `List<ScheduledMessage>`

#### POST /api/chat/schedule-message
**Purpose**: Schedule a message
**Request Body**:
```json
{
    "senderName": "string",
    "receiverName": "string",
    "message": "string",
    "scheduledTime": "long",
    "messageType": "SCHEDULED|REMINDER|BIRTHDAY|ANNIVERSARY",
    "reminderTitle": "string",
    "reminderDescription": "string"
}
```

#### DELETE /api/chat/cancel-message/{messageId}?senderName=string
**Purpose**: Cancel a scheduled message

### WebSocket Endpoints

#### /app/message
**Purpose**: Send public message
**Message Format**:
```json
{
    "senderName": "string",
    "message": "string",
    "status": "MESSAGE|JOIN|LEAVE"
}
```

#### /app/private-message
**Purpose**: Send private message
**Message Format**:
```json
{
    "senderName": "string",
    "receiverName": "string",
    "message": "string",
    "status": "MESSAGE"
}
```

#### /chatroom/public
**Purpose**: Receive public messages

#### /user/{username}/private
**Purpose**: Receive private messages

---

## 🎨 Frontend Components

### 1. App.jsx
**Purpose**: Main application component with routing
**Routes**:
- `/` → Redirect to `/login` or `/chat`
- `/login` → Login component
- `/chat` → Chat page component

### 2. Login.jsx
**Purpose**: User authentication
**Features**:
- Login form
- Signup form toggle
- Error handling
- JWT token storage

### 3. ChatPage.jsx
**Purpose**: Main chat interface
**Features**:
- WebSocket connection management
- Message sending/receiving
- User selection
- Tab management (public/private chat)

### 4. UserChatItem.jsx
**Purpose**: Individual user chat item
**Features**:
- User information display
- Pin/unpin functionality
- Online status indicator
- Click to start chat

### 5. PinnedUsers.jsx
**Purpose**: Display pinned users
**Features**:
- Pinned users list
- Unpin functionality
- Quick access to pinned users

### 6. ScheduledMessageModal.jsx
**Purpose**: Schedule message interface
**Features**:
- Message type selection
- Date/time picker
- Form validation
- Message preview

### 7. ScheduledMessagesList.jsx
**Purpose**: View and manage scheduled messages
**Features**:
- Scheduled messages list
- Cancel functionality
- Status tracking
- Filter by type

### 8. UserDashboard.jsx
**Purpose**: User account management
**Features**:
- User information display
- Logout functionality
- Account deletion
- Online status

---

## 🔄 Data Flow Diagrams

### 1. User Login Flow
```
User Input → Login.jsx → axios → UserController.login() → UserService.authenticateUser() → 
JwtService.generateToken() → LoginResponse → setJwtCookie() → Navigate to Chat
```

### 2. Real-time Message Flow
```
User Input → ChatPage.jsx → WebSocket → ChatController.receiveMessage() → 
ChatService.saveMessage() → Database → WebSocket → All Connected Clients
```

### 3. Scheduled Message Flow
```
User Input → ScheduledMessageModal.jsx → ChatController.scheduleMessage() → 
ScheduledMessageService.scheduleMessage() → Database → 
Scheduled Task (every 30s) → ChatService.saveMessage() → WebSocket → Recipient
```

### 4. User Pinning Flow
```
User Click → UserChatItem.jsx → UserController.pinUser() → 
UserService.pinUser() → Database → PinnedUsers.jsx → Display Updated List
```

---

## 🔒 Security Features

### 1. JWT Authentication
- **Token Generation**: Server-side with 256-bit secret
- **Token Storage**: Browser cookies with security flags
- **Token Validation**: Every API request
- **Token Expiration**: 24 hours

### 2. Password Security
- **Hashing**: BCrypt with salt
- **Validation**: Minimum 6 characters
- **Storage**: Hashed in database

### 3. Input Validation
- **Frontend**: Real-time validation
- **Backend**: Bean Validation (@Valid, @NotBlank, @Email, etc.)
- **SQL Injection**: Prevented by JPA/Hibernate

### 4. CORS Configuration
```java
@Bean
public CorsConfigurationSource corsConfigurationSource() {
    CorsConfiguration configuration = new CorsConfiguration();
    configuration.setAllowedOriginPatterns(Arrays.asList("*"));
    configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
    configuration.setAllowedHeaders(Arrays.asList("*"));
    configuration.setAllowCredentials(true);
    return source;
}
```

### 5. WebSocket Security
- **Origin Validation**: Allowed origins configured
- **Authentication**: JWT token validation
- **Message Validation**: Server-side validation

---

## 🚀 Deployment Guide

### Prerequisites:
- Java 17
- Node.js 16+
- MySQL 8.0
- Maven

### Backend Deployment:
1. **Database Setup**:
   ```sql
   CREATE DATABASE chat;
   CREATE USER 'chat_user'@'localhost' IDENTIFIED BY 'password';
   GRANT ALL PRIVILEGES ON chat.* TO 'chat_user'@'localhost';
   ```

2. **Application Properties**:
   ```properties
   spring.datasource.url=jdbc:mysql://localhost:3306/chat
   spring.datasource.username=chat_user
   spring.datasource.password=password
   jwt.secret=your_secure_jwt_secret_key_here
   ```

3. **Build and Run**:
   ```bash
   cd backend
   mvn clean package
   java -jar target/chat-0.0.1-SNAPSHOT.jar
   ```

### Frontend Deployment:
1. **Install Dependencies**:
   ```bash
   cd frontend
   npm install
   ```

2. **Build for Production**:
   ```bash
   npm run build
   ```

3. **Serve Static Files**:
   ```bash
   npm run preview
   ```

### Production Considerations:
- **HTTPS**: Enable SSL/TLS
- **Environment Variables**: Use for sensitive data
- **Database**: Use production MySQL instance
- **Monitoring**: Add logging and monitoring
- **Backup**: Regular database backups
- **Load Balancing**: For high traffic

---

## 📊 Performance Optimization

### Database Optimization:
- **Indexes**: On frequently queried fields
- **Connection Pooling**: Configured in application.properties
- **Query Optimization**: Use specific queries

### Frontend Optimization:
- **Code Splitting**: React lazy loading
- **Bundle Optimization**: Vite build optimization
- **Caching**: Browser caching strategies

### WebSocket Optimization:
- **Connection Pooling**: Reuse connections
- **Message Batching**: Batch multiple messages
- **Heartbeat**: Keep connections alive

---

## 🐛 Troubleshooting

### Common Issues:

#### 1. WebSocket Connection Failed
**Symptoms**: Real-time messages not working
**Solution**: Check CORS configuration and WebSocket endpoint

#### 2. JWT Token Expired
**Symptoms**: 401 Unauthorized errors
**Solution**: User needs to login again

#### 3. Database Connection Issues
**Symptoms**: 500 Internal Server Error
**Solution**: Check database credentials and connection

#### 4. Scheduled Messages Not Sending
**Symptoms**: Messages not delivered at scheduled time
**Solution**: Check @EnableScheduling annotation and scheduled task

### Debug Commands:
```bash
# Check backend logs
tail -f backend/logs/application.log

# Check database
mysql -u root -p chat

# Check frontend console
F12 → Console tab
```

---

## 📈 Future Enhancements

### Planned Features:
1. **File Upload**: Image and document sharing
2. **Message Encryption**: End-to-end encryption
3. **Group Chats**: Multi-user conversations
4. **Message Reactions**: Like, love, etc.
5. **User Profiles**: Avatars and status
6. **Message Search**: Search through chat history
7. **Push Notifications**: Browser notifications
8. **Mobile App**: React Native version

### Technical Improvements:
1. **Redis**: For session management
2. **Elasticsearch**: For message search
3. **Docker**: Containerization
4. **Kubernetes**: Orchestration
5. **Microservices**: Service decomposition

---

## 📞 Support

### Documentation:
- **API Docs**: This document
- **Code Comments**: Inline documentation
- **README**: Project overview

### Contact:
- **Issues**: GitHub Issues
- **Questions**: GitHub Discussions
- **Contributions**: Pull Requests

---

**🎉 This documentation provides a complete understanding of the PingCircle chat application, from user interactions to technical implementation details. Every feature, API call, and data flow is documented for easy understanding and maintenance.**
